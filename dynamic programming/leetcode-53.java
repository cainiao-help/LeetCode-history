/*
53. 最大子数组和
给你一个整数数组 nums ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。

子数组是数组中的一个连续部分。
示例 1：
输入：nums = [-2,1,-3,4,-1,2,1,-5,4]
输出：6
解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。
  
示例 2：
输入：nums = [1]
输出：1
  
示例 3：
输入：nums = [5,4,-1,7,8]
输出：23
 
提示：
1 <= nums.length <= 105
-104 <= nums[i] <= 104

进阶：如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的 分治法 求解。
*/

// 该题可以使用动态规划，设置一个数组，但使用数组的空间复杂度达到了O（n），可以只使用一个数维护当前的最大值，即若当前总和小于0，则将当前总和置为0，重新开始记录
// 这样确保当前的始终是大于0的，例如，若数组[-2,1,-3,4,-1,2,1,-5,4],遍历到下标0的总和为-2，则此时将-2和当前的最大值比较，若大于则替换，最后将当前总和置为0
// 继续遍历，接下来到数字1（下标也为1），当前总和为1，保存总和并比较当前最大值，继续遍历到-3的时候总和为-2小于0，则将当前总和置为0，比较后继续遍历
// 来到数字4处，当前的总和为4，比较后继续遍历，来到-1处，当前总和为3，比较后继续遍历，来到数字2，当前总和为5，比较后继续遍历，来到数字1处，当前总和为6，比较后继续遍历

    public static void main(String[] args) {
        int[] nums = {-2,1,-3,4,-1,2,1,-5,4};
        System.out.println(maxSubArray(nums));
    }

    public static int maxSubArray(int[] nums){
        int res = Integer.MIN_VALUE;             // 设置最终结果
        int  ans = 0;                            // 保存当前值的总和
        for (int i = 0; i < nums.length; i++) {  // 依次遍历数组
            ans = ans + nums[i];                 // 计算当前总和
            if (ans <= 0){                       // 若当前总和小于等于0则比较后置为0，否则比较后继续遍历
                res = Math.max(res, ans);
                ans = 0;
            }else {                                
                res = Math.max(res, ans);
            }
        }

        return res;
    }
