/*
31. 下一个排列
整数数组的一个 排列  就是将其所有成员以序列或线性顺序排列。
例如，arr = [1,2,3] ，以下这些都可以视作 arr 的排列：[1,2,3]、[1,3,2]、[3,1,2]、[2,3,1] 。
整数数组的 下一个排列 是指其整数的下一个字典序更大的排列。更正式地，如果数组的所有排列根据其字典顺序从小到大排列在一个容器中，那么数组的 下一个排列 就是在这个有序容器中排在它后面的那个排列。如果不存在下一个更大的排列，那么这个数组必须重排为字典序最小的排列（即，其元素按升序排列）。
例如，arr = [1,2,3] 的下一个排列是 [1,3,2] 。
类似地，arr = [2,3,1] 的下一个排列是 [3,1,2] 。
而 arr = [3,2,1] 的下一个排列是 [1,2,3] ，因为 [3,2,1] 不存在一个字典序更大的排列。
给你一个整数数组 nums ，找出 nums 的下一个排列。
必须 原地 修改，只允许使用额外常数空间。

示例 1：
输入：nums = [1,2,3]
输出：[1,3,2]

示例 2：
输入：nums = [3,2,1]
输出：[1,2,3]

示例 3：
输入：nums = [1,1,5]
输出：[1,5,1]

提示：
1 <= nums.length <= 100
0 <= nums[i] <= 100
*/

// 该题首先需要弄明白字典序，字典序的含义是表示英文单词在字典中的先后顺序，在计算机领域中扩展成两个任意字符串的大小关系。 在学习 字符串string 的时候，
// 我们肯定接触过两个字符串之间的比较，比如”abc“ < “acb” < “acbd”, 其规则是先比较第一个字母，如果不相等，就直接得到结果，如果相等，就比较下一个字母。
// 如果两个字符串的长度不相等，但是长的那个字符串包含了短的那个，那长的那个字符串更大（比如"acb" < “acbd”）
// 在我们进行比较之前，有一个默认的排序规则，就是‘a' < 'b' < 'c' < ... < 'z'
// 例如1，2，3这三个数字，我们能够形成6种不同的组合，即123 < 132 < 213 < 231 < 312 < 321。

// 1.从右向左，找第一个数字 x，满足 x 右边有大于 x 的数，这样可以把 x 变大。我们找到的数是 3。注意到，3 右边的数是递减的（证明见答疑），
// 所以 3 右侧相邻数字就是 3 右边最大的数。如果 3 右侧相邻数字小于 3，那么 3 右边一定没有大于 3 的数。因此，可以简化为，从右向左，找第一个小于右侧相邻数字的数 x
// 2.找 3 右边最小的大于 3 的数，即 4。由于 3 右边的数是递减的，所以从右向左找到的第一个大于 3 的数，就是 3 右边最小的大于 3 的数。然后把 4 放到 3 的位置上，
// 把 3 放到右边的三个位置中。这一步可以简化为交换 3 和 4。交换后得到 [1,4,5,3,2]。注意交换后 5,4,2 变成 5,3,2，仍然是递减的
// 3.把 4 右边的数从小到大排序。由于第二步交换后，4 右边的数 5,3,2 是递减的，所以只需要把 5,3,2 反转，就得到了答案 [1,4,2,3,5]。


    public static void main(String[] args) {
        int[] nums = {1,2,3};
    }
    // 1 2 5 4 3  -> 1 3 2 4 5
    public static void nextPermutation(int[] nums){
        int n = nums.length;
        int i = n - 2;
        while (i >= 0 && nums[i] >= nums[i + 1]) {  // 第一步：从右向左找到第一个小于右侧相邻数字的数 nums[i]
            i--;
        }
        if (i >= 0){                                // 如果找到了，进入第二步；否则跳过第二步，反转整个数组
            int j = n - 1;
            while (nums[j] <= nums[i]){             // 第二步：从右向左找到 nums[i] 右边最小的大于 nums[i] 的数 nums[j]
                j--;
            }
            swap(nums, i, j);                       // 交换 nums[i] 和 nums[j]
        }

        reverse(nums, i + 1, n - 1);                // 第三步：反转 [i+1, n-1]（如果上面跳过第二步，此时 i = -1）
        System.out.println(nums);
    }

    public static void swap(int[] nums, int i, int j){
        int temp = nums[i];
        nums[i] = nums[j];
        nums[j] = temp;
        return;
    }

    public static void reverse(int[] nums, int left, int right){
        while (left < right){
            swap(nums, left++, right--);
        }
    }
